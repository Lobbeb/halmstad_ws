[General]
network = uav_ugv.UAV2UGVSimulation
#sim-time-limit = 500s
realtimescheduler-scaling = 1
output-scalar-file = "${resultdir}/${configname}-#${runnumber}.sca"
output-vector-file = "${resultdir}/${configname}-#${runnumber}.vec"

# Gazebo pose bridge (TCP) settings are configured in [Config Communication-GazeboBridge]

# OSG Visualizer setup (3D visualization)
simtime-resolution = ns
*.visualizer.osgVisualizer.typename = "IntegratedOsgVisualizer"
*.visualizer.osgVisualizer.sceneVisualizer.axisLength = 50m
*.visualizer.osgVisualizer.sceneVisualizer.sceneMinX = 0m
*.visualizer.osgVisualizer.sceneVisualizer.sceneMinY = 0m
*.visualizer.osgVisualizer.sceneVisualizer.sceneMinZ = -1m
*.visualizer.osgVisualizer.sceneVisualizer.sceneMaxX = 100m
*.visualizer.osgVisualizer.sceneVisualizer.sceneMaxY = 100m
*.visualizer.osgVisualizer.sceneVisualizer.sceneMaxZ = 120m
*.visualizer.osgVisualizer.sceneVisualizer.cameraManipulator = "trackball"
*.visualizer.osgVisualizer.sceneVisualizer.cameraDistanceFactor = 4
*.visualizer.osgVisualizer.sceneVisualizer.clearColor = "skyblue"
*.visualizer.osgVisualizer.sceneVisualizer.sceneImage = "images/background/checkered.png"
*.visualizer.osgVisualizer.sceneVisualizer.sceneImageSize = 5m


# Visualizer - Enable mobility visualization
*.visualizer.*.mobilityVisualizer.displayMobility = true
*.visualizer.*.mobilityVisualizer.displayPositions = true
*.visualizer.*.mobilityVisualizer.displayOrientations = true
*.visualizer.*.mobilityVisualizer.displayVelocities = true
*.visualizer.*.mobilityVisualizer.displayMovementTrails = true
*.visualizer.*.mobilityVisualizer.animationSpeed = 1


# Coordinate system (100x100 map starting at origin)
*.coordinateSystem.typename = "SimpleGeographicCoordinateSystem"
*.coordinateSystem.sceneMinX = 0m
*.coordinateSystem.sceneMinY = 0m
*.coordinateSystem.sceneMinZ = -1m
*.coordinateSystem.sceneMaxX = 100m
*.coordinateSystem.sceneMaxY = 100m
*.coordinateSystem.sceneMaxZ = 120m
*.coordinateSystem.sceneLatitude = 0deg
*.coordinateSystem.sceneLongitude = 0deg

# Physical environment with green floor
*.physicalEnvironment.config = xmldoc("ground.xml")
*.visualizer.*.physicalEnvironmentVisualizer.displayObjects = true

[Config Mobility]

*.numHosts = 2

# UGV mobility - ground vehicle moving in 2D plane
*.ugv.mobility.typename = "GaussMarkovMobility"
*.ugv.mobility.constraintAreaMinX = 0m
*.ugv.mobility.constraintAreaMinY = 0m
*.ugv.mobility.constraintAreaMinZ = 0m
*.ugv.mobility.constraintAreaMaxX = 100m
*.ugv.mobility.constraintAreaMaxY = 100m
*.ugv.mobility.constraintAreaMaxZ = 0m
*.ugv.mobility.initialX = 0m
*.ugv.mobility.initialY = 0m
*.ugv.mobility.initialZ = 0m
*.ugv.mobility.speed = 10mps
*.ugv.mobility.margin = 5m
*.ugv.mobility.speedStdDev = 3mps
*.ugv.mobility.angleStdDev = 15deg
*.ugv.mobility.alpha = 0.5

*.ugv.wlan[0].radio.displayCommunicationRange = true

*.uav.mobility.typename = "SuperpositioningMobility"
*.uav.mobility.constraintAreaMinX = 0m
*.uav.mobility.constraintAreaMinY = 0m
*.uav.mobility.constraintAreaMinZ = 0m
*.uav.mobility.constraintAreaMaxX = 100m
*.uav.mobility.constraintAreaMaxY = 100m
*.uav.mobility.constraintAreaMaxZ = 120m
*.uav.mobility.numElements = 2
*.uav.mobility.element[0].typename = "AttachedMobility"
*.uav.mobility.element[0].constraintAreaMinX = 0m
*.uav.mobility.element[0].constraintAreaMinY = 0m
*.uav.mobility.element[0].constraintAreaMinZ = 0m
*.uav.mobility.element[0].constraintAreaMaxX = 100m
*.uav.mobility.element[0].constraintAreaMaxY = 100m
*.uav.mobility.element[0].constraintAreaMaxZ = 120m
*.uav.mobility.element[0].mobilityModule = "ugv.mobility"
*.uav.mobility.element[0].offsetX = 0m
*.uav.mobility.element[0].offsetY = 0m
*.uav.mobility.element[0].offsetZ = 20m
*.uav.mobility.element[1].typename = "CircleMobility"
*.uav.mobility.element[1].cx = 0m
*.uav.mobility.element[1].cy = 0m
*.uav.mobility.element[1].r = 10m
*.uav.mobility.element[1].speed = 20mps
*.uav.mobility.element[1].faceForward = true
*.uav.mobility.orientationComposition = "faceForward"

# 3D Models
*.ugv.osgModel = "3d/car.ive.(3.0).scale.0,0,0.rot"
*.uav.osgModel = "3d/drone.ive.(8.0).scale.0,0,90.rot"


# Display name
*.ugv.displayStringTextFormat = "UGV"
*.uav.displayStringTextFormat = "UAV"

[Config Communication]
extends = Mobility
# UDP Applications
# UAV as transmitter - sends packets every second
*.uav.numApps = 1
*.uav.app[0].typename = "UdpBasicApp"
*.uav.app[0].destAddresses = "ugv"
*.uav.app[0].destPort = 5000
*.uav.app[0].messageLength = 1000B
*.uav.app[0].sendInterval = 0.1s
*.uav.app[0].startTime = 0.1s
*.uav.app[0].stopTime = -0.1s

# UGV as receiver
*.ugv.numApps = 1
*.ugv.app[0].typename = "UdpSink"
*.ugv.app[0].localPort = 5000

# Radio Configuration
*.uav.wlan[0].radio.displayCommunicationRange = true
*.ugv.wlan[0].radio.displayCommunicationRange = true
*.uav.wlan[0].radio.displayInterferenceRange = false
*.ugv.wlan[0].radio.displayInterferenceRange = false

# Enable statistics collection
*.uav.wlan[0].radio.typename = "Ieee80211ScalarRadio"
*.ugv.wlan[0].radio.typename = "Ieee80211ScalarRadio"

# Detailed reception and signal recording
*.radioMedium.recordReceptionLog = true
*.radioMedium.recordTransmissionLog = true

# Radio medium configuration
*.radioMedium.pathLoss.typename = "FreeSpacePathLoss"
*.radioMedium.mediumLimitCache.carrierFrequency = 2.4GHz

# Enable detailed receiver signal statistics
*.ugv.wlan[0].radio.receiver.typename = "Ieee80211ScalarReceiver"
*.uav.wlan[0].radio.receiver.typename = "Ieee80211ScalarReceiver"

# Statistics recording
**.app[*].**.scalar-recording = true
**.app[*].**.vector-recording = true
**.wlan[*].radio.**.scalar-recording = true
**.wlan[*].radio.**.vector-recording = true
**.wlan[*].mac.**.scalar-recording = true
**.wlan[*].mac.**.vector-recording = true

**.wlan[*].radio.packetErrorRate:vector.vector-recording = true
**.wlan[*].radio.minSnir:vector.vector-recording = true
**.wlan[*].radio.packetErrorRate.result-recording-modes = +vector
**.wlan[*].radio.minSnir.result-recording-modes = +vector

# Enable SNIR and signal strength recording on UGV receiver
#*.ugv.wlan[*].radio.packetSentToUpper.result-recording-modes = all
*.ugv.wlan[*].**.scalar-recording = true
*.ugv.wlan[*].**.vector-recording = true

[Config Communication-GazeboBridge]
extends = Communication

# Keep OMNeT simulation time aligned with wall-clock/Gazebo time.
scheduler-class = "cRealTimeScheduler"

*.enableGazeboBridge = true

# UGV defaults before first Gazebo update.
*.ugv.mobility.initialX = 50m
*.ugv.mobility.initialY = 50m
*.ugv.mobility.initialZ = 0m

# Polls the ROS odometry-to-TCP bridge.
*.gazeboScheduler.host = "127.0.0.1"
*.gazeboScheduler.port = 5555
*.gazeboScheduler.updateInterval = 0.05s
*.gazeboScheduler.connectAt = 0s
*.gazeboScheduler.recvTimeoutMs = 100

# Drive UGV from Gazebo position snapshots.
*.ugv.mobility.typename = "GazeboDrivenMobility"
*.ugv.mobility.schedulerModule = "^.^.gazeboScheduler"
*.ugv.mobility.trackedModel = "x2_ugv"
*.ugv.mobility.freezeAutonomousMotion = true
*.ugv.mobility.faceForward = false
*.ugv.mobility.alignFirstPoseToInitial = false
*.ugv.mobility.ignoreZ = false
*.ugv.mobility.offsetX = 50m
*.ugv.mobility.offsetY = 50m
*.ugv.mobility.offsetZ = 0m
*.ugv.mobility.scaleX = 1
*.ugv.mobility.scaleY = -1
*.ugv.mobility.scaleZ = 1
*.ugv.mobility.yawOffset = 0deg

# Drive UAV from Gazebo position snapshots (bebop1).
*.uav.mobility.typename = "GazeboDrivenMobility"
*.uav.mobility.schedulerModule = "^.^.gazeboScheduler"
*.uav.mobility.trackedModel = "bebop1"
*.uav.mobility.freezeAutonomousMotion = true
*.uav.mobility.faceForward = false
*.uav.mobility.alignFirstPoseToInitial = false
*.uav.mobility.ignoreZ = false
*.uav.mobility.offsetX = 50m
*.uav.mobility.offsetY = 50m
*.uav.mobility.offsetZ = 0m
*.uav.mobility.scaleX = 1
*.uav.mobility.scaleY = -1
*.uav.mobility.scaleZ = 1
*.uav.mobility.yawOffset = 0deg

# UAV defaults before first Gazebo update.
*.uav.mobility.initialX = 40m
*.uav.mobility.initialY = 50m
*.uav.mobility.initialZ = 0m

# Required GaussMarkovMobility parameters (unused while freezeAutonomousMotion=true).
*.uav.mobility.speed = 0mps
*.uav.mobility.margin = 0m
*.uav.mobility.speedStdDev = 0mps
*.uav.mobility.angleStdDev = 0deg
*.uav.mobility.alpha = 1

[Config Communication-GazeboBridge-Fast]
extends = Communication-GazeboBridge

# Faster visual feedback in Qtenv/OSG while traffic is active.
# NOTE: This intentionally accelerates visual animations and may look less time-accurate.
*.visualizer.osgVisualizer.sceneVisualizer.animationSpeed = 80
*.visualizer.*.mobilityVisualizer.animationSpeed = 80
*.visualizer.*.dataLinkVisualizer.fadeOutAnimationSpeed = 80
*.visualizer.*.physicalLinkVisualizer.fadeOutAnimationSpeed = 80
*.visualizer.*.packetDropVisualizer.fadeOutAnimationSpeed = 80

# Reduce GUI overhead from dynamic text overlays.
*.visualizer.*.statisticVisualizer.displayStatistics = false
*.visualizer.*.infoVisualizer.displayInfos = false

# Reduce runtime overhead from detailed logging/recording.
*.radioMedium.recordReceptionLog = false
*.radioMedium.recordTransmissionLog = false
**.app[*].**.vector-recording = false
**.wlan[*].radio.**.vector-recording = false
**.wlan[*].mac.**.vector-recording = false
*.ugv.wlan[*].**.vector-recording = false

[Config Communication-GazeboBridge-WiFi]
extends = Communication-GazeboBridge

# Explicit WiFi baseline profile (same bridged topology as current default).
# Use this when you want a stable reference config for comparisons.
**.wlan[*].bitrate = 54Mbps
**.wlan[*].radio.transmitter.bitrate = 54Mbps
**.wlan[*].opMode = "g(mixed)"
**.wlan[*].radio.bandwidth = 20MHz
**.wlan[*].radio.transmitter.power = 20mW
*.radioMedium.mediumLimitCache.carrierFrequency = 2.4GHz
*.radioMedium.pathLoss.typename = "FreeSpacePathLoss"
**.wlan[*].radio.receiver.sensitivity = -85dBm

[Config Communication-GazeboBridge-5G]
extends = Communication-GazeboBridge

# First-pass 5G-like profile on the existing bridged two-host topology.
# NOTE: This is a PHY/link profile approximation (not a native Simu5G NR stack yet).
**.wlan[*].opMode = "ac"
**.wlan[*].radio.bandwidth = 80MHz
**.wlan[*].radio.transmitter.power = 200mW
*.radioMedium.mediumLimitCache.carrierFrequency = 3.5GHz
*.radioMedium.pathLoss.typename = "FreeSpacePathLoss"
**.wlan[*].radio.receiver.sensitivity = -95dBm

[Config Communication-GazeboBridge-LoRa]
network = uav_ugv.UAV2UGVLoRaSimulation

# Native flora LoRaWAN setup (not WiFi approximation):
#   UAV = LoRa end node, UGV = LoRa gateway, plus local NetworkServer over Ethernet.
# Requires OMNeT NED path to include flora:
#   -n src:../inet4.5/src:../flora/src
scheduler-class = "cRealTimeScheduler"
*.enableGazeboBridge = true

# Gazebo pose bridge scheduler
*.gazeboScheduler.host = "127.0.0.1"
*.gazeboScheduler.port = 5555
*.gazeboScheduler.updateInterval = 0.05s
*.gazeboScheduler.connectAt = 0s
*.gazeboScheduler.recvTimeoutMs = 100

# Keep scene/constraints aligned with the WiFi/5G bridge configs
*.configurator.assignDisjunctSubnetAddresses = false
*.coordinateSystem.typename = "SimpleGeographicCoordinateSystem"
*.coordinateSystem.sceneMinX = 0m
*.coordinateSystem.sceneMinY = 0m
*.coordinateSystem.sceneMinZ = -1m
*.coordinateSystem.sceneMaxX = 100m
*.coordinateSystem.sceneMaxY = 100m
*.coordinateSystem.sceneMaxZ = 120m
*.physicalEnvironment.config = xmldoc("ground.xml")

# LoRa medium and logging (INET RadioMedium logging still produces .tlog)
*.radioMedium.recordReceptionLog = true
*.radioMedium.recordTransmissionLog = true
*.radioMedium.pathLossType = "LoRaLogNormalShadowing"
*.radioMedium.mediumLimitCacheType = "LoRaMediumCache"
*.radioMedium.neighborCacheType = "LoRaNeighborCache"
*.radioMedium.rangeFilter = "communicationRange"
*.radioMedium.neighborCache.range = 600m
*.radioMedium.neighborCache.refillPeriod = 3000s

**.radio.radioMediumModule = "^.^.^.radioMedium"
**.maxTransmissionDuration = 4s
**.energyDetection = -110dBm
**.minInterferenceTime = 0s
**.sigma = 3.57
**.displayAddresses = false
**.radio.separateTransmissionParts = false
**.radio.separateReceptionParts = false

# LoRaWAN roles and apps
*.ugv.numEthInterfaces = 1
*.ugv.numUdpApps = 1
*.ugv.packetForwarder.localPort = 2000
*.ugv.packetForwarder.destPort = 1000
*.ugv.packetForwarder.destAddresses = "networkServer"
*.ugv.LoRaGWNic.radio.iAmGateway = true
*.ugv.LoRaGWNic.energySourceModule = "^.radio.IdealEpEnergyStorage"
*.ugv.LoRaGWNic.radio.energySourceModule = "^.IdealEpEnergyStorage"

*.networkServer.numApps = 1
*.networkServer.app[0].typename = "NetworkServerApp"
*.networkServer.app[0].localPort = 1000
*.networkServer.app[0].destAddresses = "ugv"
*.networkServer.app[0].destPort = 2000
*.networkServer.app[0].evaluateADRinServer = false
*.networkServer.app[0].adrMethod = "avg"

*.uav.numApps = 1
*.uav.app[0].typename = "SimpleLoRaApp"
*.uav.app[0].numberOfPacketsToSend = 0
*.uav.app[0].timeToFirstPacket = 1s
*.uav.app[0].timeToNextPacket = 2s
*.uav.app[0].dataSize = 32B
*.uav.app[0].initialLoRaCF = 868MHz
*.uav.app[0].initialLoRaBW = 125kHz
*.uav.app[0].initialLoRaSF = 10
*.uav.app[0].initialLoRaCR = 4
*.uav.app[0].initialLoRaTP = 14dBm
*.uav.app[0].evaluateADRinNode = false
*.uav.LoRaNic.energySourceModule = "^.radio.IdealEpEnergyStorage"
*.uav.LoRaNic.radio.energySourceModule = "^.IdealEpEnergyStorage"

# Gazebo-driven mobility for UGV gateway
*.ugv.mobility.typename = "GazeboDrivenMobility"
*.ugv.mobility.schedulerModule = "^.^.gazeboScheduler"
*.ugv.mobility.trackedModel = "x2_ugv"
*.ugv.mobility.freezeAutonomousMotion = true
*.ugv.mobility.faceForward = false
*.ugv.mobility.alignFirstPoseToInitial = false
*.ugv.mobility.ignoreZ = false
*.ugv.mobility.offsetX = 50m
*.ugv.mobility.offsetY = 50m
*.ugv.mobility.offsetZ = 0m
*.ugv.mobility.scaleX = 1
*.ugv.mobility.scaleY = -1
*.ugv.mobility.scaleZ = 1
*.ugv.mobility.yawOffset = 0deg
*.ugv.mobility.initialX = 50m
*.ugv.mobility.initialY = 50m
*.ugv.mobility.initialZ = 0m

# Gazebo-driven mobility for UAV end node
*.uav.mobility.typename = "GazeboDrivenMobility"
*.uav.mobility.schedulerModule = "^.^.gazeboScheduler"
*.uav.mobility.trackedModel = "bebop1"
*.uav.mobility.freezeAutonomousMotion = true
*.uav.mobility.faceForward = false
*.uav.mobility.alignFirstPoseToInitial = false
*.uav.mobility.ignoreZ = false
*.uav.mobility.offsetX = 50m
*.uav.mobility.offsetY = 50m
*.uav.mobility.offsetZ = 0m
*.uav.mobility.scaleX = 1
*.uav.mobility.scaleY = -1
*.uav.mobility.scaleZ = 1
*.uav.mobility.yawOffset = 0deg
*.uav.mobility.initialX = 40m
*.uav.mobility.initialY = 50m
*.uav.mobility.initialZ = 10m

# Mobility constraints (avoid out-of-bounds init before first bridge update)
*.ugv.mobility.constraintAreaMinX = 0m
*.ugv.mobility.constraintAreaMinY = 0m
*.ugv.mobility.constraintAreaMinZ = 0m
*.ugv.mobility.constraintAreaMaxX = 100m
*.ugv.mobility.constraintAreaMaxY = 100m
*.ugv.mobility.constraintAreaMaxZ = 120m
*.uav.mobility.constraintAreaMinX = 0m
*.uav.mobility.constraintAreaMinY = 0m
*.uav.mobility.constraintAreaMinZ = 0m
*.uav.mobility.constraintAreaMaxX = 100m
*.uav.mobility.constraintAreaMaxY = 100m
*.uav.mobility.constraintAreaMaxZ = 120m

# Dummy GaussMarkov params required by GazeboDrivenMobility (extends GaussMarkovMobility)
*.ugv.mobility.speed = 0mps
*.ugv.mobility.margin = 0m
*.ugv.mobility.speedStdDev = 0mps
*.ugv.mobility.angleStdDev = 0deg
*.ugv.mobility.alpha = 1
*.uav.mobility.speed = 0mps
*.uav.mobility.margin = 0m
*.uav.mobility.speedStdDev = 0mps
*.uav.mobility.angleStdDev = 0deg
*.uav.mobility.alpha = 1

# Useful recording on LoRa radios/gateway/node apps
**.LoRa*.**.scalar-recording = true
**.LoRa*.**.vector-recording = true
*.uav.app[*].**.scalar-recording = true
*.uav.app[*].**.vector-recording = true
*.networkServer.app[*].**.scalar-recording = true
*.networkServer.app[*].**.vector-recording = true
